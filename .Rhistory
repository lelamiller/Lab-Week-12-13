#' @description simulates an example day of arrivals throughout the day
#' @param arrival_rates_result data frame with the start station, end station, hour and average rate of arrival for each trip across all days.
#' @return data frame of a simulated day: origin, destination, hour
library(tidyverse)
#read in the arrival rates data
arrival_rates_result <- read.csv("~/Desktop/PHP1560/arrival_rates_result.csv")
#START THE FUNCTION!!!
simulate_one_day <- function(arrival_rates_result){
arrival_rates_result <- arrival_rates_result %>%
mutate(hour = factor(hour, levels = c(0:23))) %>%
group_by(start_station, end_station) %>%
complete(hour, fill = list(x_hat = 0))
#identify the unique pairs of stations
df_station_pair <- arrival_rates_result %>%
group_by(start_station, end_station) %>%
summarize()
full_arrivals <- data.frame( hour = vector("numeric"),
time = vector("numeric"),
start_station = vector("character"),
end_station = vector("character")
)
#vectors of the stations that we will loop through
#start a for loop for the unique pairs of stations
for (i in 1:nrow(df_station_pair)) {
#find lambda max for the unique station pair
start <- df_station_pair$start_station[i]
end <- df_station_pair$end_station[i]
lambdas <- arrival_rates_result %>%
arrange(hour) %>%
filter(start_station == start,
end_station == end) %>%
pull(x_hat)
lambda_max <- max(lambdas)
#initialize the time
t <- 0
arrivals <- c()
hourvector <- c()
#start a while loop for t, our total time, making sure it is always less than 24
while(t<24){
t <- t + rexp(1, rate = lambda_max)
if (t >=24) break
hourvector <- c(hourvector, floor(t))
#ADD IN THINNING?
if(rbinom(1, 1, lambdas[hour +1]/lambda_max) ==1){
#storing the arrivals for each hour in a vector of hourly arrivals
arrivals <- c(arrivals, t)
}
}
if (!is.null(arrivals)){
arrival_df <- data.frame(
hour = floor(arrivals),
time = arrivals,
start_station = start,
end_station = end)
full_arrivals <- rbind(full_arrivals, arrival_df)
}
}
return(full_arrivals)
}
#' @description optimizes bike placement for most riders to have a bike for their desired rides
#' @param arrival_rates_result data frame with the start station, end station, hour and average rate of arrival for each trip across all days.
#' @param nbikes number of bikes to begin with
#' @param seed for reproducibility
#' @return data frame of a simulated day: origin, destination, hour
library(tidyverse)
arrival_rates_result <- read.csv("~/Desktop/PHP1560/arrival_rates_result.csv")
optimize_bike_placement <- function(arrival_rates_result,
fleet_size,
n_days = 10,
seed = 123) {
set.seed(123)
# Get all stations appearing anywhere in dataset
stations <- sort(unique(c(arrival_rates_result$start_station)))
# Start with 0 bikes everywhere
allocation <- setNames(rep(0, length(stations)), stations)
# COMPUTE WHETHER A STATION UNHAPPY
compute_unhappy <- function(allocation) {
total_unhappy <- setNames(rep(0, length(stations)), stations)
# simulate several days
for (d in 1:10) {
sim <- simulate_one_day(arrival_rates_result)
# count arrivals per station
arrivals <- sim %>%
group_by(start_station) %>%
summarize(n_arrivals = n(), .groups = "drop")
# join with stations (to fill in zeros)
arrivals <- full_join(
arrivals,
data.frame(start_station = stations),
by = "start_station"
) %>%
mutate(n_arrivals = ifelse(is.na(n_arrivals), 0, n_arrivals))
# unhappy = arrivals > bikes currently assigned
for (s in stations) {
a <- arrivals$n_arrivals[arrivals$start_station == s]
b <- allocation[s]
total_unhappy[s] <- total_unhappy[s] + max(a - b, 0)
}
}
return(total_unhappy)
}
for (i in 1:fleet_size) {
# compute who is most unhappy right now
unhappy <- compute_unhappy(allocation)
# pick station with the maximum unhappy customers
chosen_station <- names(which.max(unhappy))
# place ONE bike there
allocation[chosen_station] <- allocation[chosen_station] + 1
}
return(data.frame(
station = stations,
recommended_bikes = as.numeric(allocation)
))
}
optimize_bike_placement(arrival_rates_result,
100,
n_days = 10,
seed = 1)
#' @description simulates an example day of arrivals throughout the day
#' @param arrival_rates_result data frame with the start station, end station, hour and average rate of arrival for each trip across all days.
#' @return data frame of a simulated day: origin, destination, hour
library(tidyverse)
#read in the arrival rates data
arrival_rates_result <- read.csv("~/Desktop/PHP1560/arrival_rates_result.csv")
#START THE FUNCTION!!!
simulate_one_day <- function(arrival_rates_result){
arrival_rates_result <- arrival_rates_result %>%
mutate(hour = factor(hour, levels = c(0:23))) %>%
group_by(start_station, end_station) %>%
complete(hour, fill = list(x_hat = 0))
#identify the unique pairs of stations
df_station_pair <- arrival_rates_result %>%
group_by(start_station, end_station) %>%
summarize()
full_arrivals <- data.frame( hour = vector("numeric"),
time = vector("numeric"),
start_station = vector("character"),
end_station = vector("character")
)
#vectors of the stations that we will loop through
#start a for loop for the unique pairs of stations
for (i in 1:nrow(df_station_pair)) {
#find lambda max for the unique station pair
start <- df_station_pair$start_station[i]
end <- df_station_pair$end_station[i]
lambdas <- arrival_rates_result %>%
arrange(hour) %>%
filter(start_station == start,
end_station == end) %>%
pull(x_hat)
lambda_max <- max(lambdas)
#initialize the time
t <- 0
arrivals <- c()
hourvector <- c()
#start a while loop for t, our total time, making sure it is always less than 24
while(t<24){
t <- t + rexp(1, rate = lambda_max)
if (t >=24) break
hourvector <- c(hourvector, floor(t))
#ADD IN THINNING?
if(rbinom(1, 1, lambdas[floor(t) + 1]/lambda_max) ==1){
#storing the arrivals for each hour in a vector of hourly arrivals
arrivals <- c(arrivals, t)
}
}
if (!is.null(arrivals)){
arrival_df <- data.frame(
hour = floor(arrivals),
time = arrivals,
start_station = start,
end_station = end)
full_arrivals <- rbind(full_arrivals, arrival_df)
}
}
return(full_arrivals)
}
#' @description optimizes bike placement for most riders to have a bike for their desired rides
#' @param arrival_rates_result data frame with the start station, end station, hour and average rate of arrival for each trip across all days.
#' @param nbikes number of bikes to begin with
#' @param seed for reproducibility
#' @return data frame of a simulated day: origin, destination, hour
library(tidyverse)
arrival_rates_result <- read.csv("~/Desktop/PHP1560/arrival_rates_result.csv")
optimize_bike_placement <- function(arrival_rates_result,
fleet_size,
n_days = 10,
seed = 123) {
set.seed(123)
# Get all stations appearing anywhere in dataset
stations <- sort(unique(c(arrival_rates_result$start_station)))
# Start with 0 bikes everywhere
allocation <- setNames(rep(0, length(stations)), stations)
# COMPUTE WHETHER A STATION UNHAPPY
compute_unhappy <- function(allocation) {
total_unhappy <- setNames(rep(0, length(stations)), stations)
# simulate several days
for (d in 1:10) {
sim <- simulate_one_day(arrival_rates_result)
# count arrivals per station
arrivals <- sim %>%
group_by(start_station) %>%
summarize(n_arrivals = n(), .groups = "drop")
# join with stations (to fill in zeros)
arrivals <- full_join(
arrivals,
data.frame(start_station = stations),
by = "start_station"
) %>%
mutate(n_arrivals = ifelse(is.na(n_arrivals), 0, n_arrivals))
# unhappy = arrivals > bikes currently assigned
for (s in stations) {
a <- arrivals$n_arrivals[arrivals$start_station == s]
b <- allocation[s]
total_unhappy[s] <- total_unhappy[s] + max(a - b, 0)
}
}
return(total_unhappy)
}
for (i in 1:fleet_size) {
# compute who is most unhappy right now
unhappy <- compute_unhappy(allocation)
# pick station with the maximum unhappy customers
chosen_station <- names(which.max(unhappy))
# place ONE bike there
allocation[chosen_station] <- allocation[chosen_station] + 1
}
return(data.frame(
station = stations,
recommended_bikes = as.numeric(allocation)
))
}
optimize_bike_placement(arrival_rates_result,
100,
n_days = 10,
seed = 1)
sim <- simulate_one_day(arrival_rates_result)
View(sim)
View(arrival_rates_result)
#' @description simulates an example day of arrivals throughout the day
#' @param arrival_rates_result data frame with the start station, end station, hour and average rate of arrival for each trip across all days.
#' @return data frame of a simulated day: origin, destination, hour
library(tidyverse)
#read in the arrival rates data
arrival_rates_result <- read.csv("~/Desktop/PHP1560/arrival_rates_result.csv")
#START THE FUNCTION!!!
simulate_one_day <- function(arrival_rates_result){
arrival_rates_result <- arrival_rates_result %>%
mutate(hour = factor(hour, levels = c(0:23))) %>%
group_by(start_station, end_station) %>%
complete(hour, fill = list(x_hat = 0))
#identify the unique pairs of stations
df_station_pair <- arrival_rates_result %>%
group_by(start_station, end_station) %>%
summarize()
full_arrivals <- data.frame( hour = vector("numeric"),
time = vector("numeric"),
start_station = vector("character"),
end_station = vector("character")
)
#vectors of the stations that we will loop through
#start a for loop for the unique pairs of stations
for (i in 1:nrow(df_station_pair)) {
#find lambda max for the unique station pair
start <- df_station_pair$start_station[i]
end <- df_station_pair$end_station[i]
lambdas <- arrival_rates_result %>%
arrange(hour) %>%
filter(start_station == start,
end_station == end) %>%
pull(x_hat)
lambda_max <- max(lambdas)
#initialize the time
t <- 0
arrivals <- c()
hourvector <- c()
#start a while loop for t, our total time, making sure it is always less than 24
while(t<24){
t <- t + rexp(1, rate = lambda_max)
if (t >=24) break
hourvector <- c(hourvector, floor(t))
#ADD IN THINNING?
if(rbinom(1, 1, lambdas[floor(t) + 1]/lambda_max) ==1){
#storing the arrivals for each hour in a vector of hourly arrivals
arrivals <- c(arrivals, t)
}
}
if (!is.null(arrivals)){
arrival_df <- data.frame(
hour = floor(arrivals),
time = arrivals,
start_station = start,
end_station = end)
full_arrivals <- rbind(full_arrivals, arrival_df)
full_arrivals <- full_arrivals[order(full_arrivals$time), ]
}
}
return(full_arrivals)
}
View(arrival_rates_result)
sim <- simulate_one_day(arrival_rates_result)
View(sim)
sim <- simulate_one_day(arrival_rates_result)
View(sim)
View(simulate_one_day)
#' @description simulates an example day of arrivals throughout the day
#' @param arrival_rates_result data frame with the start station, end station, hour and average rate of arrival for each trip across all days.
#' @return data frame of a simulated day: origin, destination, hour
library(tidyverse)
#read in the arrival rates data
# arrival_rates_result <- read.csv("/Users/lelamiller/arrival_rates_result.csv")
arrival_rates_result <- read.csv("~/Desktop/PHP1560/arrival_rates_result.csv")
#START THE FUNCTION!!!
simulate_one_day <- function(arrival_rates_result){
arrival_rates_result <- arrival_rates_result %>%
mutate(hour = factor(hour, levels = c(0:23))) %>%
group_by(start_station, end_station) %>%
complete(hour, fill = list(x_hat = 0))
#identify the unique pairs of stations
df_station_pair <- arrival_rates_result %>%
group_by(start_station, end_station) %>%
summarize()
full_arrivals <- data.frame( hour = vector("numeric"),
time = vector("numeric"),
start_station = vector("character"),
end_station = vector("character")
)
#vectors of the stations that we will loop through
#start a for loop for the unique pairs of stations
for (i in 1:nrow(df_station_pair)) {
#find lambda max for the unique station pair
start <- df_station_pair$start_station[i]
end <- df_station_pair$end_station[i]
lambdas <- arrival_rates_result %>%
arrange(hour) %>%
filter(start_station == start,
end_station == end) %>%
pull(x_hat)
lambda_max <- max(lambdas)
#initialize the time
t <- 0
arrivals <- c()
hourvector <- c()
#start a while loop for t, our total time, making sure it is always less than 24
while(t<24){
t <- t + rexp(1, rate = lambda_max)
if (t >=24) break
hourvector <- c(hourvector, floor(t))
#ADD IN THINNING?
if(rbinom(1, 1, lambdas[floor(t) + 1]/lambda_max) ==1){
#storing the arrivals for each hour in a vector of hourly arrivals
arrivals <- c(arrivals, t)
}
}
if (!is.null(arrivals)){
arrival_df <- data.frame(
hour = floor(arrivals),
time = arrivals,
start_station = start,
end_station = end)
full_arrivals <- rbind(full_arrivals, arrival_df)
full_arrivals <- full_arrivals[order(full_arrivals$time), ]
}
}
return(full_arrivals)
}
sim <- simulate_one_day(arrival_rates_result)
View(sim)
#' @description simulates an example day of arrivals throughout the day
#' @param arrival_rates_result data frame with the start station, end station, hour and average rate of arrival for each trip across all days.
#' @return data frame of a simulated day: origin, destination, hour
library(tidyverse)
#read in the arrival rates data
# arrival_rates_result <- read.csv("/Users/lelamiller/arrival_rates_result.csv")
arrival_rates_result <- read.csv("~/Desktop/PHP1560/arrival_rates_result.csv")
#START THE FUNCTION!!!
simulate_one_day <- function(arrival_rates_result){
arrival_rates_result <- arrival_rates_result %>%
mutate(hour = factor(hour, levels = c(0:23))) %>%
group_by(start_station, end_station) %>%
complete(hour, fill = list(x_hat = 0))
#identify the unique pairs of stations
df_station_pair <- arrival_rates_result %>%
group_by(start_station, end_station) %>%
summarize()
full_arrivals <- data.frame( hour = vector("numeric"),
time = vector("numeric"),
start_station = vector("character"),
end_station = vector("character")
)
#vectors of the stations that we will loop through
#start a for loop for the unique pairs of stations
for (i in 1:nrow(df_station_pair)) {
#find lambda max for the unique station pair
start <- df_station_pair$start_station[i]
end <- df_station_pair$end_station[i]
lambdas <- arrival_rates_result %>%
arrange(hour) %>%
filter(start_station == start,
end_station == end) %>%
pull(x_hat)
lambda_max <- max(lambdas)
#initialize the time
t <- 0
arrivals <- c()
hourvector <- c()
#start a while loop for t, our total time, making sure it is always less than 24
while(t<24){
t <- t + rexp(1, rate = lambda_max)
if (t >=24) break
hourvector <- c(hourvector, floor(t))
#ADD IN THINNING?
if(rbinom(1, 1, lambdas[floor(t) + 1]/lambda_max) ==1){
#storing the arrivals for each hour in a vector of hourly arrivals
arrivals <- c(arrivals, t)
}
}
if (!is.null(arrivals)){
arrival_df <- data.frame(
hour = floor(arrivals),
time = arrivals,
start_station = start,
end_station = end)
full_arrivals <- rbind(full_arrivals, arrival_df)
full_arrivals <- full_arrivals[order(full_arrivals$time), ]
}
}
return(full_arrivals)
}
#test_data <- data.frame(hour = c(1, 2, 3, 0, 1, 2, 3),
#                       x_hat = c(1, 2, 0, 2, 3, 1, 2),
#                      start_station = c("A", "A","A", "B", "B", "B", "B"),
#                     end_station = c("B", "B", "B", "A", "A", "A","A")) %>%
# mutate(hour = factor(hour, levels = c(0:3))) %>%
#group_by(start_station, end_station) %>%
#complete(hour, fill = list(x_hat = 0))
#simulate_one_day(arrival_rates_result)
sim <- simulate_one_day(arrival_rates_result)
View(sim)
#' @description simulates an example day of arrivals throughout the day
#' @param arrival_rates_result data frame with the start station, end station, hour and average rate of arrival for each trip across all days.
#' @return data frame of a simulated day: origin, destination, hour
library(tidyverse)
#read in the arrival rates data
# arrival_rates_result <- read.csv("/Users/lelamiller/arrival_rates_result.csv")
arrival_rates_result <- read.csv("~/Desktop/PHP1560/arrival_rates_result.csv")
#START THE FUNCTION!!!
simulate_one_day <- function(arrival_rates_result){
arrival_rates_result <- arrival_rates_result %>%
mutate(hour = factor(hour, levels = c(0:23))) %>%
group_by(start_station, end_station) %>%
complete(hour, fill = list(x_hat = 0))
#identify the unique pairs of stations
df_station_pair <- arrival_rates_result %>%
group_by(start_station, end_station) %>%
summarize()
full_arrivals <- data.frame( hour = vector("numeric"),
time = vector("numeric"),
start_station = vector("character"),
end_station = vector("character")
)
#vectors of the stations that we will loop through
#start a for loop for the unique pairs of stations
for (i in 1:nrow(df_station_pair)) {
#find lambda max for the unique station pair
start <- df_station_pair$start_station[i]
end <- df_station_pair$end_station[i]
lambdas <- arrival_rates_result %>%
arrange(hour) %>%
filter(start_station == start,
end_station == end) %>%
pull(x_hat)
lambda_max <- max(lambdas)
#initialize the time
t <- 0
arrivals <- c()
hourvector <- c()
#start a while loop for t, our total time, making sure it is always less than 24
while(t<24){
t <- t + rexp(1, rate = lambda_max)
if (t >=24) break
hourvector <- c(hourvector, floor(t))
#ADD IN THINNING?
if(rbinom(1, 1, lambdas[floor(t) + 1]/lambda_max) ==1){
#storing the arrivals for each hour in a vector of hourly arrivals
arrivals <- c(arrivals, t)
}
}
if (!is.null(arrivals)){
arrival_df <- data.frame(
hour = floor(arrivals),
time = arrivals,
start_station = start,
end_station = end)
full_arrivals <- rbind(full_arrivals, arrival_df)
full_arrivals <- full_arrivals %>%
arrange(time)
}
}
return(full_arrivals)
}
#test_data <- data.frame(hour = c(1, 2, 3, 0, 1, 2, 3),
#                       x_hat = c(1, 2, 0, 2, 3, 1, 2),
#                      start_station = c("A", "A","A", "B", "B", "B", "B"),
#                     end_station = c("B", "B", "B", "A", "A", "A","A")) %>%
# mutate(hour = factor(hour, levels = c(0:3))) %>%
#group_by(start_station, end_station) %>%
#complete(hour, fill = list(x_hat = 0))
#simulate_one_day(arrival_rates_result)
sim <- simulate_one_day(arrival_rates_result)
View(sim)
View(sim)
